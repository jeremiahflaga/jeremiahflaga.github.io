---
layout: post
title: "Entity Framework Core child entities in <code>.Include()</code> are empty when using <code>.Take()</code>"
excerpt: 
date: 2025-04-20 12:00:00 PM UTC
dateLastUpdated:
categories:
  - Programming
tags: 
  - Entity Framework Core
sidebar_content: <small><small><center><em>"Where I Belong" by Switchfoot</em></center></small></small> <iframe width="100%" src="https://www.youtube.com/embed/s3-7fjhYm2g?si=-O3lMyA3-f2EsbyW" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
---

I was having this bug when using `.Include(x => x.Children)` and `.Take()` of Entity Framework Core. The bug was that the child entities specified in the `.Include()` statement are not included in the result of the query (see `Children.Count = 0` in the image below):

![](/images/2025/2025-04-20-1-ef-core-include-children-empty-with-take.png)

But when I comment out the line `.Take(input.Count)`, all of a sudden the children are included in the result of the query:

![](/images/2025/2025-04-20-2-ef-core-include-children-not-empty-with-no-take.png)

When I inspected the SQL query generated by EF Core, I got this message:

`This LINQ query is being executed in split-query mode, and the SQL shown is for the first query to be executed. Additional queries may also be executed depending on the results of the first query.`

![](/images/2025/2025-04-20-3-ef-core-include-with-take-query-string.png)

I did more googling and found out the reason for the bug in the documentation for EF Core:

> When using split queries with Skip/Take on EF versions prior to 10, pay special attention to making your query ordering fully unique; not doing so could cause incorrect data to be returned. For example, if results are ordered only by date, but there can be multiple results with the same date, then each one of the split queries could each get different results from the database. Ordering by both date and ID (or any other unique property or combination of properties) makes the ordering fully unique and avoids this problem. Note that relational databases do not apply any ordering by default, even on the primary key.
>
> --- from ["Single vs. Split Queries" of EF Core documentation](https://learn.microsoft.com/en-us/ef/core/querying/single-split-queries)

So the solution is to modify the `.OrderBy()` expression so that the ordering in the query is unique. In my case, I used the `Id` property of the parent entities for the ordering.

Problem solved.
